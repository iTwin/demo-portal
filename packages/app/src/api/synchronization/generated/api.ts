/*---------------------------------------------------------------------------------------------
 * Copyright (c) Bentley Systems, Incorporated. All rights reserved.
 * See LICENSE.md in the project root for license terms and full copyright notice.
 *
 * This code is for demonstration purposes and should not be considered production ready.
 *--------------------------------------------------------------------------------------------*/
/* eslint-disable */
//@ts-nocheck
/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Synchronization
 * iModel Connections API is a cloud-based synchronization API meant to synchronize the data in Input Files and iModels. It allows users to establish links from their design files to iModels, hosted in Bentley's iModelHub. Users can synchronize updates to their design files.
 *
 * OpenAPI spec version: v1
 *
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */
import * as isomorphicFetch from "isomorphic-fetch";
import * as url from "url";

import { Configuration } from "./configuration";

export const BASE_PATH = "https://api.bentley.com/synchronization".replace(
  /\/+$/,
  ""
);

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
  csv: ",",
  ssv: " ",
  tsv: "\t",
  pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
  (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
  url: string;
  options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
  protected configuration: Configuration;

  constructor(
    configuration?: Configuration,
    protected basePath: string = BASE_PATH,
    protected fetch: FetchAPI = isomorphicFetch
  ) {
    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }
}

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
  name: "RequiredError";
  constructor(public field: string, msg?: string) {
    super(msg);
  }
}

/**
 *
 * @export
 * @interface AuthorizationInformationLinksSynchronizationAPI
 */
export interface AuthorizationInformationLinksSynchronizationAPI {
  /**
   *
   * @type {LinkSynchronizationAPI}
   * @memberof AuthorizationInformationLinksSynchronizationAPI
   */
  authorizationUrl?: LinkSynchronizationAPI;
}
/**
 *
 * @export
 * @interface AuthorizationInformationResponseSynchronizationAPI
 */
export interface AuthorizationInformationResponseSynchronizationAPI {
  /**
   *
   * @type {AuthorizationInformationSynchronizationAPI}
   * @memberof AuthorizationInformationResponseSynchronizationAPI
   */
  authorizationInformation?: AuthorizationInformationSynchronizationAPI;
}
/**
 *
 * @export
 * @interface AuthorizationInformationSynchronizationAPI
 */
export interface AuthorizationInformationSynchronizationAPI {
  /**
   *
   * @type {boolean}
   * @memberof AuthorizationInformationSynchronizationAPI
   */
  isUserAuthorized?: boolean;
  /**
   *
   * @type {AuthorizationInformationLinksSynchronizationAPI}
   * @memberof AuthorizationInformationSynchronizationAPI
   */
  _links?: AuthorizationInformationLinksSynchronizationAPI;
}
/**
 *
 * @export
 * @interface ConnectionLinksSynchronizationAPI
 */
export interface ConnectionLinksSynchronizationAPI {
  /**
   *
   * @type {LinkSynchronizationAPI}
   * @memberof ConnectionLinksSynchronizationAPI
   */
  iModel?: LinkSynchronizationAPI;
  /**
   *
   * @type {LinkSynchronizationAPI}
   * @memberof ConnectionLinksSynchronizationAPI
   */
  project?: LinkSynchronizationAPI;
  /**
   *
   * @type {LinkSynchronizationAPI}
   * @memberof ConnectionLinksSynchronizationAPI
   */
  lastRun?: LinkSynchronizationAPI;
}
/**
 *
 * @export
 * @interface ConnectionSummarySynchronizationAPI
 */
export interface ConnectionSummarySynchronizationAPI {
  /**
   *
   * @type {string}
   * @memberof ConnectionSummarySynchronizationAPI
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ConnectionSummarySynchronizationAPI
   */
  displayName?: string;
}
/**
 *
 * @export
 * @interface ConnectionSynchronizationAPI
 */
export interface ConnectionSynchronizationAPI {
  /**
   *
   * @type {string}
   * @memberof ConnectionSynchronizationAPI
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof ConnectionSynchronizationAPI
   */
  displayName?: string;
  /**
   *
   * @type {string}
   * @memberof ConnectionSynchronizationAPI
   */
  iModelId?: string;
  /**
   *
   * @type {ConnectionLinksSynchronizationAPI}
   * @memberof ConnectionSynchronizationAPI
   */
  _links?: ConnectionLinksSynchronizationAPI;
}
/**
 *
 * @export
 * @interface ConnectionsPreferReturnMinimalSynchronizationAPI
 */
export interface ConnectionsPreferReturnMinimalSynchronizationAPI {
  /**
   *
   * @type {Array<ConnectionSummarySynchronizationAPI>}
   * @memberof ConnectionsPreferReturnMinimalSynchronizationAPI
   */
  connections?: Array<ConnectionSummarySynchronizationAPI>;
  /**
   *
   * @type {LinksSynchronizationAPI}
   * @memberof ConnectionsPreferReturnMinimalSynchronizationAPI
   */
  _links?: LinksSynchronizationAPI;
}
/**
 *
 * @export
 * @interface ConnectionsPreferReturnRepresentationSynchronizationAPI
 */
export interface ConnectionsPreferReturnRepresentationSynchronizationAPI {
  /**
   *
   * @type {Array<ConnectionSynchronizationAPI>}
   * @memberof ConnectionsPreferReturnRepresentationSynchronizationAPI
   */
  connections?: Array<ConnectionSynchronizationAPI>;
  /**
   *
   * @type {LinksSynchronizationAPI}
   * @memberof ConnectionsPreferReturnRepresentationSynchronizationAPI
   */
  _links?: LinksSynchronizationAPI;
}
/**
 * One of 'NotSet', 'AFFINITYCHECKER, 'MSTN', 'AVEVAPID', 'AUTOPLANT', 'REVIT', 'DWG', 'SPXREVIEW', 'IFC', 'SPPID', 'AVEVADIAGRAMS', 'CIVIL', 'CIVIL3D', 'GEOSPATIAL', 'OBD', 'OPENTOWER', 'SHELLEDWCSV', 'NWD'. Name of the Connector that is used for synchronization.
 * @export
 * @enum {string}
 */
export enum ConnectorTypeSynchronizationAPI {
  NotSet = <any>"NotSet",
  AFFINITYCHECKER = <any>"AFFINITYCHECKER",
  MSTN = <any>"MSTN",
  AVEVAPID = <any>"AVEVAPID",
  AUTOPLANT = <any>"AUTOPLANT",
  REVIT = <any>"REVIT",
  DWG = <any>"DWG",
  SPXREVIEW = <any>"SPXREVIEW",
  IFC = <any>"IFC",
  SPPID = <any>"SPPID",
  AVEVADIAGRAMS = <any>"AVEVADIAGRAMS",
  CIVIL = <any>"CIVIL",
  CIVIL3D = <any>"CIVIL3D",
  GEOSPATIAL = <any>"GEOSPATIAL",
  OBD = <any>"OBD",
  OPENTOWER = <any>"OPENTOWER",
  SHELLEDWCSV = <any>"SHELLEDWCSV",
  NWD = <any>"NWD",
}
/**
 * One of 'Undetermined', 'Success', 'Error', 'PartialSuccess', 'Skipped', 'Cancelled', 'TimedOut'.
 * @export
 * @enum {string}
 */
export enum ExecutionResultSynchronizationAPI {
  Undetermined = <any>"Undetermined",
  Success = <any>"Success",
  Error = <any>"Error",
  PartialSuccess = <any>"PartialSuccess",
  Skipped = <any>"Skipped",
  Cancelled = <any>"Cancelled",
  TimedOut = <any>"TimedOut",
}
/**
 * One of 'NotStarted', 'Idle', 'WaitingToExecute', 'WaitingToRetry', 'Executing', 'Finalizing', 'Completed', 'Queued'.
 * @export
 * @enum {string}
 */
export enum ExecutionStateSynchronizationAPI {
  NotStarted = <any>"NotStarted",
  Idle = <any>"Idle",
  WaitingToExecute = <any>"WaitingToExecute",
  WaitingToRetry = <any>"WaitingToRetry",
  Executing = <any>"Executing",
  Finalizing = <any>"Finalizing",
  Completed = <any>"Completed",
  Queued = <any>"Queued",
}
/**
 *
 * @export
 * @interface FileLinksSynchronizationAPI
 */
export interface FileLinksSynchronizationAPI {
  /**
   *
   * @type {LinkSynchronizationAPI}
   * @memberof FileLinksSynchronizationAPI
   */
  file?: LinkSynchronizationAPI;
}
/**
 * One of 'Preprocessor', 'MasterFile', 'ReferenceFile'.
 * @export
 * @enum {string}
 */
export enum JobPhaseSynchronizationAPI {
  Preprocessor = <any>"Preprocessor",
  MasterFile = <any>"MasterFile",
  ReferenceFile = <any>"ReferenceFile",
}
/**
 *
 * @export
 * @interface JobSynchronizationAPI
 */
export interface JobSynchronizationAPI {
  /**
   *
   * @type {string}
   * @memberof JobSynchronizationAPI
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof JobSynchronizationAPI
   */
  startDateTime?: string;
  /**
   *
   * @type {string}
   * @memberof JobSynchronizationAPI
   */
  endDateTime?: string;
  /**
   *
   * @type {string}
   * @memberof JobSynchronizationAPI
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof JobSynchronizationAPI
   */
  result?: string;
  /**
   *
   * @type {ConnectorTypeSynchronizationAPI}
   * @memberof JobSynchronizationAPI
   */
  connectorType?: ConnectorTypeSynchronizationAPI;
  /**
   *
   * @type {Array<TaskSynchronizationAPI>}
   * @memberof JobSynchronizationAPI
   */
  tasks?: Array<TaskSynchronizationAPI>;
}
/**
 *
 * @export
 * @interface LinkSynchronizationAPI
 */
export interface LinkSynchronizationAPI {
  /**
   *
   * @type {string}
   * @memberof LinkSynchronizationAPI
   */
  href?: string;
}
/**
 *
 * @export
 * @interface LinksSynchronizationAPI
 */
export interface LinksSynchronizationAPI {
  /**
   *
   * @type {LinkSynchronizationAPI}
   * @memberof LinksSynchronizationAPI
   */
  self?: LinkSynchronizationAPI;
  /**
   *
   * @type {LinkSynchronizationAPI}
   * @memberof LinksSynchronizationAPI
   */
  next?: LinkSynchronizationAPI;
  /**
   *
   * @type {LinkSynchronizationAPI}
   * @memberof LinksSynchronizationAPI
   */
  prev?: LinkSynchronizationAPI;
}
/**
 *
 * @export
 * @interface RunResponseSynchronizationAPI
 */
export interface RunResponseSynchronizationAPI {
  /**
   *
   * @type {RunSynchronizationAPI}
   * @memberof RunResponseSynchronizationAPI
   */
  run?: RunSynchronizationAPI;
}
/**
 *
 * @export
 * @interface RunSummarySynchronizationAPI
 */
export interface RunSummarySynchronizationAPI {
  /**
   *
   * @type {string}
   * @memberof RunSummarySynchronizationAPI
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof RunSummarySynchronizationAPI
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof RunSummarySynchronizationAPI
   */
  result?: string;
}
/**
 *
 * @export
 * @interface RunSynchronizationAPI
 */
export interface RunSynchronizationAPI {
  /**
   *
   * @type {string}
   * @memberof RunSynchronizationAPI
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof RunSynchronizationAPI
   */
  connectionId?: string;
  /**
   *
   * @type {string}
   * @memberof RunSynchronizationAPI
   */
  startDateTime?: string;
  /**
   *
   * @type {string}
   * @memberof RunSynchronizationAPI
   */
  endDateTime?: string;
  /**
   *
   * @type {JobPhaseSynchronizationAPI}
   * @memberof RunSynchronizationAPI
   */
  phase?: JobPhaseSynchronizationAPI;
  /**
   *
   * @type {ExecutionStateSynchronizationAPI}
   * @memberof RunSynchronizationAPI
   */
  state?: ExecutionStateSynchronizationAPI;
  /**
   *
   * @type {ExecutionResultSynchronizationAPI}
   * @memberof RunSynchronizationAPI
   */
  result?: ExecutionResultSynchronizationAPI;
  /**
   *
   * @type {Array<JobSynchronizationAPI>}
   * @memberof RunSynchronizationAPI
   */
  jobs?: Array<JobSynchronizationAPI>;
}
/**
 *
 * @export
 * @interface RunsPreferReturnMinimalSynchronizationAPI
 */
export interface RunsPreferReturnMinimalSynchronizationAPI {
  /**
   *
   * @type {Array<RunSummarySynchronizationAPI>}
   * @memberof RunsPreferReturnMinimalSynchronizationAPI
   */
  runs?: Array<RunSummarySynchronizationAPI>;
}
/**
 *
 * @export
 * @interface RunsPreferReturnRepresentationSynchronizationAPI
 */
export interface RunsPreferReturnRepresentationSynchronizationAPI {
  /**
   *
   * @type {Array<RunSynchronizationAPI>}
   * @memberof RunsPreferReturnRepresentationSynchronizationAPI
   */
  runs?: Array<RunSynchronizationAPI>;
}
/**
 *
 * @export
 * @interface StorageConnectionCreateSynchronizationAPI
 */
export interface StorageConnectionCreateSynchronizationAPI {
  /**
   *
   * @type {string}
   * @memberof StorageConnectionCreateSynchronizationAPI
   */
  displayName?: string;
  /**
   *
   * @type {string}
   * @memberof StorageConnectionCreateSynchronizationAPI
   */
  iModelId: string;
  /**
   *
   * @type {Array<StorageFileCreateSynchronizationAPI>}
   * @memberof StorageConnectionCreateSynchronizationAPI
   */
  sourceFiles: Array<StorageFileCreateSynchronizationAPI>;
}
/**
 *
 * @export
 * @interface StorageConnectionResponseSynchronizationAPI
 */
export interface StorageConnectionResponseSynchronizationAPI {
  /**
   *
   * @type {StorageConnectionSynchronizationAPI}
   * @memberof StorageConnectionResponseSynchronizationAPI
   */
  connection?: StorageConnectionSynchronizationAPI;
}
/**
 *
 * @export
 * @interface StorageConnectionSummarySynchronizationAPI
 */
export interface StorageConnectionSummarySynchronizationAPI {
  /**
   *
   * @type {string}
   * @memberof StorageConnectionSummarySynchronizationAPI
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof StorageConnectionSummarySynchronizationAPI
   */
  displayName?: string;
}
/**
 *
 * @export
 * @interface StorageConnectionSynchronizationAPI
 */
export interface StorageConnectionSynchronizationAPI {
  /**
   *
   * @type {string}
   * @memberof StorageConnectionSynchronizationAPI
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof StorageConnectionSynchronizationAPI
   */
  displayName?: string;
  /**
   *
   * @type {string}
   * @memberof StorageConnectionSynchronizationAPI
   */
  iModelId?: string;
  /**
   *
   * @type {ConnectionLinksSynchronizationAPI}
   * @memberof StorageConnectionSynchronizationAPI
   */
  _links?: ConnectionLinksSynchronizationAPI;
}
/**
 *
 * @export
 * @interface StorageFileCreateSynchronizationAPI
 */
export interface StorageFileCreateSynchronizationAPI {
  /**
   *
   * @type {string}
   * @memberof StorageFileCreateSynchronizationAPI
   */
  storageFileId: string;
  /**
   *
   * @type {ConnectorTypeSynchronizationAPI}
   * @memberof StorageFileCreateSynchronizationAPI
   */
  connectorType: ConnectorTypeSynchronizationAPI;
}
/**
 *
 * @export
 * @interface StorageFilePreferReturnMinimalSynchronizationAPI
 */
export interface StorageFilePreferReturnMinimalSynchronizationAPI {
  /**
   *
   * @type {Array<StorageFileSummarySynchronizationAPI>}
   * @memberof StorageFilePreferReturnMinimalSynchronizationAPI
   */
  sourceFiles?: Array<StorageFileSummarySynchronizationAPI>;
}
/**
 *
 * @export
 * @interface StorageFilePreferReturnRepresentationSynchronizationAPI
 */
export interface StorageFilePreferReturnRepresentationSynchronizationAPI {
  /**
   *
   * @type {Array<StorageFileSynchronizationAPI>}
   * @memberof StorageFilePreferReturnRepresentationSynchronizationAPI
   */
  sourceFiles?: Array<StorageFileSynchronizationAPI>;
}
/**
 *
 * @export
 * @interface StorageFileResponseSynchronizationAPI
 */
export interface StorageFileResponseSynchronizationAPI {
  /**
   *
   * @type {StorageFileSynchronizationAPI}
   * @memberof StorageFileResponseSynchronizationAPI
   */
  sourceFile?: StorageFileSynchronizationAPI;
}
/**
 *
 * @export
 * @interface StorageFileSummarySynchronizationAPI
 */
export interface StorageFileSummarySynchronizationAPI {
  /**
   *
   * @type {string}
   * @memberof StorageFileSummarySynchronizationAPI
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof StorageFileSummarySynchronizationAPI
   */
  storageFileId?: string;
}
/**
 *
 * @export
 * @interface StorageFileSynchronizationAPI
 */
export interface StorageFileSynchronizationAPI {
  /**
   *
   * @type {string}
   * @memberof StorageFileSynchronizationAPI
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof StorageFileSynchronizationAPI
   */
  storageFileId?: string;
  /**
   *
   * @type {ConnectorTypeSynchronizationAPI}
   * @memberof StorageFileSynchronizationAPI
   */
  connectorType?: ConnectorTypeSynchronizationAPI;
  /**
   *
   * @type {string}
   * @memberof StorageFileSynchronizationAPI
   */
  lastKnownFileName?: string;
  /**
   *
   * @type {FileLinksSynchronizationAPI}
   * @memberof StorageFileSynchronizationAPI
   */
  _links?: FileLinksSynchronizationAPI;
}
/**
 *
 * @export
 * @interface TaskSynchronizationAPI
 */
export interface TaskSynchronizationAPI {
  /**
   *
   * @type {string}
   * @memberof TaskSynchronizationAPI
   */
  id?: string;
  /**
   *
   * @type {string}
   * @memberof TaskSynchronizationAPI
   */
  startDateTime?: string;
  /**
   *
   * @type {string}
   * @memberof TaskSynchronizationAPI
   */
  endDateTime?: string;
  /**
   *
   * @type {number}
   * @memberof TaskSynchronizationAPI
   */
  retryAttempts?: number;
  /**
   *
   * @type {string}
   * @memberof TaskSynchronizationAPI
   */
  storageFileId?: string;
  /**
   *
   * @type {string}
   * @memberof TaskSynchronizationAPI
   */
  state?: string;
  /**
   *
   * @type {string}
   * @memberof TaskSynchronizationAPI
   */
  result?: string;
}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function(
  configuration?: Configuration
) {
  return {
    /**
     * ---    Add a new Storage Source File to a Storage Connection    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.    #### ConnectorType    Valid ConnectorType values are:    -NotSet  -AFFINITYCHECKER  -MSTN  -AVEVAPID  -AUTOPLANT  -REVIT  -DWG  -SPXREVIEW  -IFC  -SPPID  -AVEVADIAGRAMS  -CIVIL  -CIVIL3D  -GEOSPATIAL  -OBD  -OPENTOWER  -SHELLEDWCSV  -NWD    ### Associated entities  SourceFile is added to a Connection. The reuqest path must contain a valid Connection ID    ---
     * @summary Add StorageConnection SourceFile
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {StorageFileCreateSynchronizationAPI} [body]
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addStorageConnectionSourcefile(
      connectionId: string,
      Authorization: string,
      body?: StorageFileCreateSynchronizationAPI,
      Accept?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'connectionId' is not null or undefined
      if (connectionId === null || connectionId === undefined) {
        throw new RequiredError(
          "connectionId",
          "Required parameter connectionId was null or undefined when calling addStorageConnectionSourcefile."
        );
      }
      // verify required parameter 'Authorization' is not null or undefined
      if (Authorization === null || Authorization === undefined) {
        throw new RequiredError(
          "Authorization",
          "Required parameter Authorization was null or undefined when calling addStorageConnectionSourcefile."
        );
      }
      const localVarPath = `/imodels/storageConnections/{connectionId}/sourcefiles`.replace(
        `{${"connectionId"}}`,
        encodeURIComponent(String(connectionId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyHeader required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("X-Api-Subscription-Key")
            : configuration.apiKey;
        localVarHeaderParameter["X-Api-Subscription-Key"] = localVarApiKeyValue;
      }

      // authentication apiKeyQuery required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("subscription-key")
            : configuration.apiKey;
        localVarQueryParameter["subscription-key"] = localVarApiKeyValue;
      }

      if (Authorization !== undefined && Authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(Authorization);
      }

      if (Accept !== undefined && Accept !== null) {
        localVarHeaderParameter["Accept"] = String(Accept);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"StorageFileCreateSynchronizationAPI" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ---    Create a StorageConnection that describes files from Storage to synchronize to the iModel.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.    ### Associated entities    A connection is linked with an iModel. An iModel ID is required to be set when creating a StorageConnection.    ---
     * @summary Create StorageConnection
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {StorageConnectionCreateSynchronizationAPI} [body]
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStorageConnection(
      Authorization: string,
      body?: StorageConnectionCreateSynchronizationAPI,
      Accept?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'Authorization' is not null or undefined
      if (Authorization === null || Authorization === undefined) {
        throw new RequiredError(
          "Authorization",
          "Required parameter Authorization was null or undefined when calling createStorageConnection."
        );
      }
      const localVarPath = `/imodels/storageConnections`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyHeader required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("X-Api-Subscription-Key")
            : configuration.apiKey;
        localVarHeaderParameter["X-Api-Subscription-Key"] = localVarApiKeyValue;
      }

      // authentication apiKeyQuery required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("subscription-key")
            : configuration.apiKey;
        localVarQueryParameter["subscription-key"] = localVarApiKeyValue;
      }

      if (Authorization !== undefined && Authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(Authorization);
      }

      if (Accept !== undefined && Accept !== null) {
        localVarHeaderParameter["Accept"] = String(Accept);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"StorageConnectionCreateSynchronizationAPI" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ---    Delete connection    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.      ---
     * @summary Delete StorageConnection
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteStorageConnection(
      connectionId: string,
      Authorization: string,
      Accept?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'connectionId' is not null or undefined
      if (connectionId === null || connectionId === undefined) {
        throw new RequiredError(
          "connectionId",
          "Required parameter connectionId was null or undefined when calling deleteStorageConnection."
        );
      }
      // verify required parameter 'Authorization' is not null or undefined
      if (Authorization === null || Authorization === undefined) {
        throw new RequiredError(
          "Authorization",
          "Required parameter Authorization was null or undefined when calling deleteStorageConnection."
        );
      }
      const localVarPath = `/imodels/storageConnections/{connectionId}`.replace(
        `{${"connectionId"}}`,
        encodeURIComponent(String(connectionId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyHeader required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("X-Api-Subscription-Key")
            : configuration.apiKey;
        localVarHeaderParameter["X-Api-Subscription-Key"] = localVarApiKeyValue;
      }

      // authentication apiKeyQuery required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("subscription-key")
            : configuration.apiKey;
        localVarQueryParameter["subscription-key"] = localVarApiKeyValue;
      }

      if (Authorization !== undefined && Authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(Authorization);
      }

      if (Accept !== undefined && Accept !== null) {
        localVarHeaderParameter["Accept"] = String(Accept);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ---    Retrieves the calling user's AuthorizationInformation.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get AuthorizationInformation
     * @param {string} redirectUrl URL to redirect back to after authorization
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthorizationInformation(
      redirectUrl: string,
      Authorization: string,
      Accept?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'redirectUrl' is not null or undefined
      if (redirectUrl === null || redirectUrl === undefined) {
        throw new RequiredError(
          "redirectUrl",
          "Required parameter redirectUrl was null or undefined when calling getAuthorizationInformation."
        );
      }
      // verify required parameter 'Authorization' is not null or undefined
      if (Authorization === null || Authorization === undefined) {
        throw new RequiredError(
          "Authorization",
          "Required parameter Authorization was null or undefined when calling getAuthorizationInformation."
        );
      }
      const localVarPath = `/imodels/connections/authorizationInformation`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyHeader required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("X-Api-Subscription-Key")
            : configuration.apiKey;
        localVarHeaderParameter["X-Api-Subscription-Key"] = localVarApiKeyValue;
      }

      // authentication apiKeyQuery required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("subscription-key")
            : configuration.apiKey;
        localVarQueryParameter["subscription-key"] = localVarApiKeyValue;
      }

      if (redirectUrl !== undefined) {
        localVarQueryParameter["redirectUrl"] = redirectUrl;
      }

      if (Authorization !== undefined && Authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(Authorization);
      }

      if (Accept !== undefined && Accept !== null) {
        localVarHeaderParameter["Accept"] = String(Accept);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ---    Retrieves connections for the specified iModel.    ### Notes    The `Prefer` header can be used to specify how much result metadata is desired by the client. The `Prefer` request header field is used to indicate that particular server behaviors are preferred by the client but are not required for successful completion of the request.    This operation supports `\"return=representation\"` and `\"return=minimal\"` preferences.    The `\"return=representation\"` preference indicates that the client prefers that the server include an entity representing the current state of the resource in the response to a successful request.  The `\"return=minimal\"` preference indicates that the client wishes the server to return only a minimal response to a successful request. This is the default preference if `Prefer` header is not specified.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get Connections
     * @param {string} imodelId iModel Id
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {number} [top] The [$top](https://www.odata.org/getting-started/basic-tutorial/#topskip) system query option requests the number of items in the queried collection to be included in the result.
     * @param {number} [skip] The [$skip](https://www.odata.org/getting-started/basic-tutorial/#topskip) query option requests the number of items in the queried collection that are to be skipped and not included in the result.
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnections(
      imodelId: string,
      Authorization: string,
      top?: number,
      skip?: number,
      Accept?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'imodelId' is not null or undefined
      if (imodelId === null || imodelId === undefined) {
        throw new RequiredError(
          "imodelId",
          "Required parameter imodelId was null or undefined when calling getConnections."
        );
      }
      // verify required parameter 'Authorization' is not null or undefined
      if (Authorization === null || Authorization === undefined) {
        throw new RequiredError(
          "Authorization",
          "Required parameter Authorization was null or undefined when calling getConnections."
        );
      }
      const localVarPath = `/imodels/connections`;
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyHeader required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("X-Api-Subscription-Key")
            : configuration.apiKey;
        localVarHeaderParameter["X-Api-Subscription-Key"] = localVarApiKeyValue;
      }

      // authentication apiKeyQuery required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("subscription-key")
            : configuration.apiKey;
        localVarQueryParameter["subscription-key"] = localVarApiKeyValue;
      }

      if (imodelId !== undefined) {
        localVarQueryParameter["imodelId"] = imodelId;
      }

      if (top !== undefined) {
        localVarQueryParameter["$top"] = top;
      }

      if (skip !== undefined) {
        localVarQueryParameter["$skip"] = skip;
      }

      if (Authorization !== undefined && Authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(Authorization);
      }

      if (Accept !== undefined && Accept !== null) {
        localVarHeaderParameter["Accept"] = String(Accept);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ---    Retrieves a StorageConnection with the specified ID.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get Storage Connection
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConnection(
      connectionId: string,
      Authorization: string,
      Accept?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'connectionId' is not null or undefined
      if (connectionId === null || connectionId === undefined) {
        throw new RequiredError(
          "connectionId",
          "Required parameter connectionId was null or undefined when calling getStorageConnection."
        );
      }
      // verify required parameter 'Authorization' is not null or undefined
      if (Authorization === null || Authorization === undefined) {
        throw new RequiredError(
          "Authorization",
          "Required parameter Authorization was null or undefined when calling getStorageConnection."
        );
      }
      const localVarPath = `/imodels/storageConnections/{connectionId}`.replace(
        `{${"connectionId"}}`,
        encodeURIComponent(String(connectionId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyHeader required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("X-Api-Subscription-Key")
            : configuration.apiKey;
        localVarHeaderParameter["X-Api-Subscription-Key"] = localVarApiKeyValue;
      }

      // authentication apiKeyQuery required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("subscription-key")
            : configuration.apiKey;
        localVarQueryParameter["subscription-key"] = localVarApiKeyValue;
      }

      if (Authorization !== undefined && Authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(Authorization);
      }

      if (Accept !== undefined && Accept !== null) {
        localVarHeaderParameter["Accept"] = String(Accept);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ---    Retrieves a StorageConnection Run with the specified ID.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get Storage Connection Run
     * @param {string} connectionId
     * @param {string} runId Run Id
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {number} [top] The [$top](https://www.odata.org/getting-started/basic-tutorial/#topskip) system query option requests the number of items in the queried collection to be included in the result.
     * @param {number} [skip] The [$skip](https://www.odata.org/getting-started/basic-tutorial/#topskip) query option requests the number of items in the queried collection that are to be skipped and not included in the result.
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConnectionRun(
      connectionId: string,
      runId: string,
      Authorization: string,
      top?: number,
      skip?: number,
      Accept?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'connectionId' is not null or undefined
      if (connectionId === null || connectionId === undefined) {
        throw new RequiredError(
          "connectionId",
          "Required parameter connectionId was null or undefined when calling getStorageConnectionRun."
        );
      }
      // verify required parameter 'runId' is not null or undefined
      if (runId === null || runId === undefined) {
        throw new RequiredError(
          "runId",
          "Required parameter runId was null or undefined when calling getStorageConnectionRun."
        );
      }
      // verify required parameter 'Authorization' is not null or undefined
      if (Authorization === null || Authorization === undefined) {
        throw new RequiredError(
          "Authorization",
          "Required parameter Authorization was null or undefined when calling getStorageConnectionRun."
        );
      }
      const localVarPath = `/imodels/storageConnections/{connectionId}/runs/{runId}`
        .replace(
          `{${"connectionId"}}`,
          encodeURIComponent(String(connectionId))
        )
        .replace(`{${"runId"}}`, encodeURIComponent(String(runId)));
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyHeader required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("X-Api-Subscription-Key")
            : configuration.apiKey;
        localVarHeaderParameter["X-Api-Subscription-Key"] = localVarApiKeyValue;
      }

      // authentication apiKeyQuery required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("subscription-key")
            : configuration.apiKey;
        localVarQueryParameter["subscription-key"] = localVarApiKeyValue;
      }

      if (top !== undefined) {
        localVarQueryParameter["$top"] = top;
      }

      if (skip !== undefined) {
        localVarQueryParameter["$skip"] = skip;
      }

      if (Authorization !== undefined && Authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(Authorization);
      }

      if (Accept !== undefined && Accept !== null) {
        localVarHeaderParameter["Accept"] = String(Accept);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ---    Retrieves all Runs for the specified connection.    ### Notes    The `Prefer` header can be used to specify how much result metadata is desired by the client. The `Prefer` request header field is used to indicate that particular server behaviors are preferred by the client but are not required for successful completion of the request.    This operation supports `\"return=representation\"` and `\"return=minimal\"` preferences.    The `\"return=representation\"` preference indicates that the client prefers that the server include an entity representing the current state of the resource in the response to a successful request.  The `\"return=minimal\"` preference indicates that the client wishes the server to return only a minimal response to a successful request. This is the default preference if `Prefer` header is not specified.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get StorageConnection Runs
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConnectionRuns(
      connectionId: string,
      Authorization: string,
      Accept?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'connectionId' is not null or undefined
      if (connectionId === null || connectionId === undefined) {
        throw new RequiredError(
          "connectionId",
          "Required parameter connectionId was null or undefined when calling getStorageConnectionRuns."
        );
      }
      // verify required parameter 'Authorization' is not null or undefined
      if (Authorization === null || Authorization === undefined) {
        throw new RequiredError(
          "Authorization",
          "Required parameter Authorization was null or undefined when calling getStorageConnectionRuns."
        );
      }
      const localVarPath = `/imodels/storageConnections/{connectionId}/runs`.replace(
        `{${"connectionId"}}`,
        encodeURIComponent(String(connectionId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyHeader required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("X-Api-Subscription-Key")
            : configuration.apiKey;
        localVarHeaderParameter["X-Api-Subscription-Key"] = localVarApiKeyValue;
      }

      // authentication apiKeyQuery required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("subscription-key")
            : configuration.apiKey;
        localVarQueryParameter["subscription-key"] = localVarApiKeyValue;
      }

      if (Authorization !== undefined && Authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(Authorization);
      }

      if (Accept !== undefined && Accept !== null) {
        localVarHeaderParameter["Accept"] = String(Accept);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ---    Retrieves StorageConnection's SourceFile with the specified ID.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get StorageConnection SourceFile
     * @param {string} connectionId
     * @param {string} sourceFileId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {number} [top] The [$top](https://www.odata.org/getting-started/basic-tutorial/#topskip) system query option requests the number of items in the queried collection to be included in the result.
     * @param {number} [skip] The [$skip](https://www.odata.org/getting-started/basic-tutorial/#topskip) query option requests the number of items in the queried collection that are to be skipped and not included in the result.
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConnectionSourcefile(
      connectionId: string,
      sourceFileId: string,
      Authorization: string,
      top?: number,
      skip?: number,
      Accept?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'connectionId' is not null or undefined
      if (connectionId === null || connectionId === undefined) {
        throw new RequiredError(
          "connectionId",
          "Required parameter connectionId was null or undefined when calling getStorageConnectionSourcefile."
        );
      }
      // verify required parameter 'sourceFileId' is not null or undefined
      if (sourceFileId === null || sourceFileId === undefined) {
        throw new RequiredError(
          "sourceFileId",
          "Required parameter sourceFileId was null or undefined when calling getStorageConnectionSourcefile."
        );
      }
      // verify required parameter 'Authorization' is not null or undefined
      if (Authorization === null || Authorization === undefined) {
        throw new RequiredError(
          "Authorization",
          "Required parameter Authorization was null or undefined when calling getStorageConnectionSourcefile."
        );
      }
      const localVarPath = `/imodels/storageConnections/{connectionId}/sourcefiles/{sourceFileId}`
        .replace(
          `{${"connectionId"}}`,
          encodeURIComponent(String(connectionId))
        )
        .replace(
          `{${"sourceFileId"}}`,
          encodeURIComponent(String(sourceFileId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyHeader required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("X-Api-Subscription-Key")
            : configuration.apiKey;
        localVarHeaderParameter["X-Api-Subscription-Key"] = localVarApiKeyValue;
      }

      // authentication apiKeyQuery required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("subscription-key")
            : configuration.apiKey;
        localVarQueryParameter["subscription-key"] = localVarApiKeyValue;
      }

      if (top !== undefined) {
        localVarQueryParameter["$top"] = top;
      }

      if (skip !== undefined) {
        localVarQueryParameter["$skip"] = skip;
      }

      if (Authorization !== undefined && Authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(Authorization);
      }

      if (Accept !== undefined && Accept !== null) {
        localVarHeaderParameter["Accept"] = String(Accept);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ---    Retrieves SourceFiles for specified StorageConnection.    ### Notes    The `Prefer` header can be used to specify how much result metadata is desired by the client. The `Prefer` request header field is used to indicate that particular server behaviors are preferred by the client but are not required for successful completion of the request.    This operation supports `\"return=representation\"` and `\"return=minimal\"` preferences.    The `\"return=representation\"` preference indicates that the client prefers that the server include an entity representing the current state of the resource in the response to a successful request.  The `\"return=minimal\"` preference indicates that the client wishes the server to return only a minimal response to a successful request. This is the default preference if `Prefer` header is not specified.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get StorageConnection SourceFiles
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConnectionSourcefiles(
      connectionId: string,
      Authorization: string,
      Accept?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'connectionId' is not null or undefined
      if (connectionId === null || connectionId === undefined) {
        throw new RequiredError(
          "connectionId",
          "Required parameter connectionId was null or undefined when calling getStorageConnectionSourcefiles."
        );
      }
      // verify required parameter 'Authorization' is not null or undefined
      if (Authorization === null || Authorization === undefined) {
        throw new RequiredError(
          "Authorization",
          "Required parameter Authorization was null or undefined when calling getStorageConnectionSourcefiles."
        );
      }
      const localVarPath = `/imodels/storageConnections/{connectionId}/sourcefiles`.replace(
        `{${"connectionId"}}`,
        encodeURIComponent(String(connectionId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "GET" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyHeader required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("X-Api-Subscription-Key")
            : configuration.apiKey;
        localVarHeaderParameter["X-Api-Subscription-Key"] = localVarApiKeyValue;
      }

      // authentication apiKeyQuery required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("subscription-key")
            : configuration.apiKey;
        localVarQueryParameter["subscription-key"] = localVarApiKeyValue;
      }

      if (Authorization !== undefined && Authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(Authorization);
      }

      if (Accept !== undefined && Accept !== null) {
        localVarHeaderParameter["Accept"] = String(Accept);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ---    Delete StorageConnection SourceFile    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.      ---
     * @summary Remove StorageConnection SourceFile
     * @param {string} connectionId Connection Id
     * @param {string} sourceFileId SourceFile Id
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeStorageConnectionSourcefile(
      connectionId: string,
      sourceFileId: string,
      Authorization: string,
      Accept?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'connectionId' is not null or undefined
      if (connectionId === null || connectionId === undefined) {
        throw new RequiredError(
          "connectionId",
          "Required parameter connectionId was null or undefined when calling removeStorageConnectionSourcefile."
        );
      }
      // verify required parameter 'sourceFileId' is not null or undefined
      if (sourceFileId === null || sourceFileId === undefined) {
        throw new RequiredError(
          "sourceFileId",
          "Required parameter sourceFileId was null or undefined when calling removeStorageConnectionSourcefile."
        );
      }
      // verify required parameter 'Authorization' is not null or undefined
      if (Authorization === null || Authorization === undefined) {
        throw new RequiredError(
          "Authorization",
          "Required parameter Authorization was null or undefined when calling removeStorageConnectionSourcefile."
        );
      }
      const localVarPath = `/imodels/storageConnections/{connectionId}/sourcefiles/{sourceFileId}`
        .replace(
          `{${"connectionId"}}`,
          encodeURIComponent(String(connectionId))
        )
        .replace(
          `{${"sourceFileId"}}`,
          encodeURIComponent(String(sourceFileId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign(
        { method: "DELETE" },
        options
      );
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyHeader required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("X-Api-Subscription-Key")
            : configuration.apiKey;
        localVarHeaderParameter["X-Api-Subscription-Key"] = localVarApiKeyValue;
      }

      // authentication apiKeyQuery required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("subscription-key")
            : configuration.apiKey;
        localVarQueryParameter["subscription-key"] = localVarApiKeyValue;
      }

      if (Authorization !== undefined && Authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(Authorization);
      }

      if (Accept !== undefined && Accept !== null) {
        localVarHeaderParameter["Accept"] = String(Accept);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ---    Runs the specified StorageConnection.    ### Notes    On successful run, operation returns http status code 202/accepted - the request is accepted for processing and will execute in background. It returns location header pointing to the run to check it's status via property 'State'(NotStarted, Idle, WaitingToExecute, WaitingToRetry, Executing, Completed, Queued). In the event that multiple run requests are being made simultaneously, 409/conflict is returned and only the first request is processed. If the run is already initiated and active, a new run is not initiated, instead 303/see other is returned along with location header pointing to the active run. There can only be one active run per iModel and another run can be initated only once the active run is complete.    ### Authentication    Requires Authorization header with valid Bearer token for scope *connection:modify*.    ---
     * @summary Run StorageConnection
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runStorageConnection(
      connectionId: string,
      Authorization: string,
      Accept?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'connectionId' is not null or undefined
      if (connectionId === null || connectionId === undefined) {
        throw new RequiredError(
          "connectionId",
          "Required parameter connectionId was null or undefined when calling runStorageConnection."
        );
      }
      // verify required parameter 'Authorization' is not null or undefined
      if (Authorization === null || Authorization === undefined) {
        throw new RequiredError(
          "Authorization",
          "Required parameter Authorization was null or undefined when calling runStorageConnection."
        );
      }
      const localVarPath = `/imodels/storageConnections/{connectionId}/run`.replace(
        `{${"connectionId"}}`,
        encodeURIComponent(String(connectionId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "POST" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyHeader required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("X-Api-Subscription-Key")
            : configuration.apiKey;
        localVarHeaderParameter["X-Api-Subscription-Key"] = localVarApiKeyValue;
      }

      // authentication apiKeyQuery required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("subscription-key")
            : configuration.apiKey;
        localVarQueryParameter["subscription-key"] = localVarApiKeyValue;
      }

      if (Authorization !== undefined && Authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(Authorization);
      }

      if (Accept !== undefined && Accept !== null) {
        localVarHeaderParameter["Accept"] = String(Accept);
      }

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ---    Update an existing StorageConnection.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.    ### Associated entities    A connection is linked with an iModel. The iModel ID is required to be set when updating a StorageConnection.    ---
     * @summary Update StorageConnection
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {StorageConnectionCreateSynchronizationAPI} [body]
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStorageConnection(
      connectionId: string,
      Authorization: string,
      body?: StorageConnectionCreateSynchronizationAPI,
      Accept?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'connectionId' is not null or undefined
      if (connectionId === null || connectionId === undefined) {
        throw new RequiredError(
          "connectionId",
          "Required parameter connectionId was null or undefined when calling updateStorageConnection."
        );
      }
      // verify required parameter 'Authorization' is not null or undefined
      if (Authorization === null || Authorization === undefined) {
        throw new RequiredError(
          "Authorization",
          "Required parameter Authorization was null or undefined when calling updateStorageConnection."
        );
      }
      const localVarPath = `/imodels/storageConnections/{connectionId}`.replace(
        `{${"connectionId"}}`,
        encodeURIComponent(String(connectionId))
      );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyHeader required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("X-Api-Subscription-Key")
            : configuration.apiKey;
        localVarHeaderParameter["X-Api-Subscription-Key"] = localVarApiKeyValue;
      }

      // authentication apiKeyQuery required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("subscription-key")
            : configuration.apiKey;
        localVarQueryParameter["subscription-key"] = localVarApiKeyValue;
      }

      if (Authorization !== undefined && Authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(Authorization);
      }

      if (Accept !== undefined && Accept !== null) {
        localVarHeaderParameter["Accept"] = String(Accept);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"StorageConnectionCreateSynchronizationAPI" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * ---    Update an existing StorageConnection SourceFile.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.    #### ConnectorType    Valid ConnectorType values are:    -NotSet  -AFFINITYCHECKER  -MSTN  -AVEVAPID  -AUTOPLANT  -REVIT  -DWG  -SPXREVIEW  -IFC  -SPPID  -AVEVADIAGRAMS  -CIVIL  -CIVIL3D  -GEOSPATIAL  -OBD  -OPENTOWER  -SHELLEDWCSV  -NWD    ### Associated entities  SourceFile is related to a Connection. The path must contain a valid Connection ID.    ---
     * @summary Update StorageConnection SourceFile
     * @param {string} connectionId
     * @param {string} sourceFileId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {StorageFileCreateSynchronizationAPI} [body]
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStorageConnectionSourcefile(
      connectionId: string,
      sourceFileId: string,
      Authorization: string,
      body?: StorageFileCreateSynchronizationAPI,
      Accept?: string,
      options: any = {}
    ): FetchArgs {
      // verify required parameter 'connectionId' is not null or undefined
      if (connectionId === null || connectionId === undefined) {
        throw new RequiredError(
          "connectionId",
          "Required parameter connectionId was null or undefined when calling updateStorageConnectionSourcefile."
        );
      }
      // verify required parameter 'sourceFileId' is not null or undefined
      if (sourceFileId === null || sourceFileId === undefined) {
        throw new RequiredError(
          "sourceFileId",
          "Required parameter sourceFileId was null or undefined when calling updateStorageConnectionSourcefile."
        );
      }
      // verify required parameter 'Authorization' is not null or undefined
      if (Authorization === null || Authorization === undefined) {
        throw new RequiredError(
          "Authorization",
          "Required parameter Authorization was null or undefined when calling updateStorageConnectionSourcefile."
        );
      }
      const localVarPath = `/imodels/storageConnections/{connectionId}/sourcefiles/{sourceFileId}`
        .replace(
          `{${"connectionId"}}`,
          encodeURIComponent(String(connectionId))
        )
        .replace(
          `{${"sourceFileId"}}`,
          encodeURIComponent(String(sourceFileId))
        );
      const localVarUrlObj = url.parse(localVarPath, true);
      const localVarRequestOptions = Object.assign({ method: "PUT" }, options);
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication apiKeyHeader required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("X-Api-Subscription-Key")
            : configuration.apiKey;
        localVarHeaderParameter["X-Api-Subscription-Key"] = localVarApiKeyValue;
      }

      // authentication apiKeyQuery required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === "function"
            ? configuration.apiKey("subscription-key")
            : configuration.apiKey;
        localVarQueryParameter["subscription-key"] = localVarApiKeyValue;
      }

      if (Authorization !== undefined && Authorization !== null) {
        localVarHeaderParameter["Authorization"] = String(Authorization);
      }

      if (Accept !== undefined && Accept !== null) {
        localVarHeaderParameter["Accept"] = String(Accept);
      }

      localVarHeaderParameter["Content-Type"] = "application/json";

      localVarUrlObj.query = Object.assign(
        {},
        localVarUrlObj.query,
        localVarQueryParameter,
        options.query
      );
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      localVarRequestOptions.headers = Object.assign(
        {},
        localVarHeaderParameter,
        options.headers
      );
      const needsSerialization =
        <any>"StorageFileCreateSynchronizationAPI" !== "string" ||
        localVarRequestOptions.headers["Content-Type"] === "application/json";
      localVarRequestOptions.body = needsSerialization
        ? JSON.stringify(body || {})
        : body || "";

      return {
        url: url.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
  return {
    /**
     * ---    Add a new Storage Source File to a Storage Connection    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.    #### ConnectorType    Valid ConnectorType values are:    -NotSet  -AFFINITYCHECKER  -MSTN  -AVEVAPID  -AUTOPLANT  -REVIT  -DWG  -SPXREVIEW  -IFC  -SPPID  -AVEVADIAGRAMS  -CIVIL  -CIVIL3D  -GEOSPATIAL  -OBD  -OPENTOWER  -SHELLEDWCSV  -NWD    ### Associated entities  SourceFile is added to a Connection. The reuqest path must contain a valid Connection ID    ---
     * @summary Add StorageConnection SourceFile
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {StorageFileCreateSynchronizationAPI} [body]
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addStorageConnectionSourcefile(
      connectionId: string,
      Authorization: string,
      body?: StorageFileCreateSynchronizationAPI,
      Accept?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<StorageFileResponseSynchronizationAPI> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).addStorageConnectionSourcefile(
        connectionId,
        Authorization,
        body,
        Accept,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * ---    Create a StorageConnection that describes files from Storage to synchronize to the iModel.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.    ### Associated entities    A connection is linked with an iModel. An iModel ID is required to be set when creating a StorageConnection.    ---
     * @summary Create StorageConnection
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {StorageConnectionCreateSynchronizationAPI} [body]
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStorageConnection(
      Authorization: string,
      body?: StorageConnectionCreateSynchronizationAPI,
      Accept?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<StorageConnectionResponseSynchronizationAPI> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).createStorageConnection(Authorization, body, Accept, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * ---    Delete connection    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.      ---
     * @summary Delete StorageConnection
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteStorageConnection(
      connectionId: string,
      Authorization: string,
      Accept?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).deleteStorageConnection(connectionId, Authorization, Accept, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * ---    Retrieves the calling user's AuthorizationInformation.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get AuthorizationInformation
     * @param {string} redirectUrl URL to redirect back to after authorization
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthorizationInformation(
      redirectUrl: string,
      Authorization: string,
      Accept?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<AuthorizationInformationResponseSynchronizationAPI> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).getAuthorizationInformation(
        redirectUrl,
        Authorization,
        Accept,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * ---    Retrieves connections for the specified iModel.    ### Notes    The `Prefer` header can be used to specify how much result metadata is desired by the client. The `Prefer` request header field is used to indicate that particular server behaviors are preferred by the client but are not required for successful completion of the request.    This operation supports `\"return=representation\"` and `\"return=minimal\"` preferences.    The `\"return=representation\"` preference indicates that the client prefers that the server include an entity representing the current state of the resource in the response to a successful request.  The `\"return=minimal\"` preference indicates that the client wishes the server to return only a minimal response to a successful request. This is the default preference if `Prefer` header is not specified.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get Connections
     * @param {string} imodelId iModel Id
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {number} [top] The [$top](https://www.odata.org/getting-started/basic-tutorial/#topskip) system query option requests the number of items in the queried collection to be included in the result.
     * @param {number} [skip] The [$skip](https://www.odata.org/getting-started/basic-tutorial/#topskip) query option requests the number of items in the queried collection that are to be skipped and not included in the result.
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnections(
      imodelId: string,
      Authorization: string,
      top?: number,
      skip?: number,
      Accept?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<ConnectionsPreferReturnMinimalSynchronizationAPI> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).getConnections(imodelId, Authorization, top, skip, Accept, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * ---    Retrieves a StorageConnection with the specified ID.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get Storage Connection
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConnection(
      connectionId: string,
      Authorization: string,
      Accept?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<StorageConnectionResponseSynchronizationAPI> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).getStorageConnection(connectionId, Authorization, Accept, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * ---    Retrieves a StorageConnection Run with the specified ID.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get Storage Connection Run
     * @param {string} connectionId
     * @param {string} runId Run Id
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {number} [top] The [$top](https://www.odata.org/getting-started/basic-tutorial/#topskip) system query option requests the number of items in the queried collection to be included in the result.
     * @param {number} [skip] The [$skip](https://www.odata.org/getting-started/basic-tutorial/#topskip) query option requests the number of items in the queried collection that are to be skipped and not included in the result.
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConnectionRun(
      connectionId: string,
      runId: string,
      Authorization: string,
      top?: number,
      skip?: number,
      Accept?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<RunResponseSynchronizationAPI> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).getStorageConnectionRun(
        connectionId,
        runId,
        Authorization,
        top,
        skip,
        Accept,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * ---    Retrieves all Runs for the specified connection.    ### Notes    The `Prefer` header can be used to specify how much result metadata is desired by the client. The `Prefer` request header field is used to indicate that particular server behaviors are preferred by the client but are not required for successful completion of the request.    This operation supports `\"return=representation\"` and `\"return=minimal\"` preferences.    The `\"return=representation\"` preference indicates that the client prefers that the server include an entity representing the current state of the resource in the response to a successful request.  The `\"return=minimal\"` preference indicates that the client wishes the server to return only a minimal response to a successful request. This is the default preference if `Prefer` header is not specified.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get StorageConnection Runs
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConnectionRuns(
      connectionId: string,
      Authorization: string,
      Accept?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<RunsPreferReturnMinimalSynchronizationAPI> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).getStorageConnectionRuns(connectionId, Authorization, Accept, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * ---    Retrieves StorageConnection's SourceFile with the specified ID.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get StorageConnection SourceFile
     * @param {string} connectionId
     * @param {string} sourceFileId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {number} [top] The [$top](https://www.odata.org/getting-started/basic-tutorial/#topskip) system query option requests the number of items in the queried collection to be included in the result.
     * @param {number} [skip] The [$skip](https://www.odata.org/getting-started/basic-tutorial/#topskip) query option requests the number of items in the queried collection that are to be skipped and not included in the result.
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConnectionSourcefile(
      connectionId: string,
      sourceFileId: string,
      Authorization: string,
      top?: number,
      skip?: number,
      Accept?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<StorageFileResponseSynchronizationAPI> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).getStorageConnectionSourcefile(
        connectionId,
        sourceFileId,
        Authorization,
        top,
        skip,
        Accept,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * ---    Retrieves SourceFiles for specified StorageConnection.    ### Notes    The `Prefer` header can be used to specify how much result metadata is desired by the client. The `Prefer` request header field is used to indicate that particular server behaviors are preferred by the client but are not required for successful completion of the request.    This operation supports `\"return=representation\"` and `\"return=minimal\"` preferences.    The `\"return=representation\"` preference indicates that the client prefers that the server include an entity representing the current state of the resource in the response to a successful request.  The `\"return=minimal\"` preference indicates that the client wishes the server to return only a minimal response to a successful request. This is the default preference if `Prefer` header is not specified.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get StorageConnection SourceFiles
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConnectionSourcefiles(
      connectionId: string,
      Authorization: string,
      Accept?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<StorageFilePreferReturnMinimalSynchronizationAPI> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).getStorageConnectionSourcefiles(
        connectionId,
        Authorization,
        Accept,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * ---    Delete StorageConnection SourceFile    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.      ---
     * @summary Remove StorageConnection SourceFile
     * @param {string} connectionId Connection Id
     * @param {string} sourceFileId SourceFile Id
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeStorageConnectionSourcefile(
      connectionId: string,
      sourceFileId: string,
      Authorization: string,
      Accept?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).removeStorageConnectionSourcefile(
        connectionId,
        sourceFileId,
        Authorization,
        Accept,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * ---    Runs the specified StorageConnection.    ### Notes    On successful run, operation returns http status code 202/accepted - the request is accepted for processing and will execute in background. It returns location header pointing to the run to check it's status via property 'State'(NotStarted, Idle, WaitingToExecute, WaitingToRetry, Executing, Completed, Queued). In the event that multiple run requests are being made simultaneously, 409/conflict is returned and only the first request is processed. If the run is already initiated and active, a new run is not initiated, instead 303/see other is returned along with location header pointing to the active run. There can only be one active run per iModel and another run can be initated only once the active run is complete.    ### Authentication    Requires Authorization header with valid Bearer token for scope *connection:modify*.    ---
     * @summary Run StorageConnection
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runStorageConnection(
      connectionId: string,
      Authorization: string,
      Accept?: string,
      options?: any
    ): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).runStorageConnection(connectionId, Authorization, Accept, options);
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response;
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * ---    Update an existing StorageConnection.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.    ### Associated entities    A connection is linked with an iModel. The iModel ID is required to be set when updating a StorageConnection.    ---
     * @summary Update StorageConnection
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {StorageConnectionCreateSynchronizationAPI} [body]
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStorageConnection(
      connectionId: string,
      Authorization: string,
      body?: StorageConnectionCreateSynchronizationAPI,
      Accept?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<StorageConnectionResponseSynchronizationAPI> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).updateStorageConnection(
        connectionId,
        Authorization,
        body,
        Accept,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
    /**
     * ---    Update an existing StorageConnection SourceFile.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.    #### ConnectorType    Valid ConnectorType values are:    -NotSet  -AFFINITYCHECKER  -MSTN  -AVEVAPID  -AUTOPLANT  -REVIT  -DWG  -SPXREVIEW  -IFC  -SPPID  -AVEVADIAGRAMS  -CIVIL  -CIVIL3D  -GEOSPATIAL  -OBD  -OPENTOWER  -SHELLEDWCSV  -NWD    ### Associated entities  SourceFile is related to a Connection. The path must contain a valid Connection ID.    ---
     * @summary Update StorageConnection SourceFile
     * @param {string} connectionId
     * @param {string} sourceFileId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {StorageFileCreateSynchronizationAPI} [body]
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStorageConnectionSourcefile(
      connectionId: string,
      sourceFileId: string,
      Authorization: string,
      body?: StorageFileCreateSynchronizationAPI,
      Accept?: string,
      options?: any
    ): (
      fetch?: FetchAPI,
      basePath?: string
    ) => Promise<StorageFileResponseSynchronizationAPI> {
      const localVarFetchArgs = DefaultApiFetchParamCreator(
        configuration
      ).updateStorageConnectionSourcefile(
        connectionId,
        sourceFileId,
        Authorization,
        body,
        Accept,
        options
      );
      return (
        fetch: FetchAPI = isomorphicFetch,
        basePath: string = BASE_PATH
      ) => {
        return fetch(
          basePath + localVarFetchArgs.url,
          localVarFetchArgs.options
        ).then((response) => {
          if (response.status >= 200 && response.status < 300) {
            return response.json();
          } else {
            throw response;
          }
        });
      };
    },
  };
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function(
  configuration?: Configuration,
  fetch?: FetchAPI,
  basePath?: string
) {
  return {
    /**
     * ---    Add a new Storage Source File to a Storage Connection    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.    #### ConnectorType    Valid ConnectorType values are:    -NotSet  -AFFINITYCHECKER  -MSTN  -AVEVAPID  -AUTOPLANT  -REVIT  -DWG  -SPXREVIEW  -IFC  -SPPID  -AVEVADIAGRAMS  -CIVIL  -CIVIL3D  -GEOSPATIAL  -OBD  -OPENTOWER  -SHELLEDWCSV  -NWD    ### Associated entities  SourceFile is added to a Connection. The reuqest path must contain a valid Connection ID    ---
     * @summary Add StorageConnection SourceFile
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {StorageFileCreateSynchronizationAPI} [body]
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addStorageConnectionSourcefile(
      connectionId: string,
      Authorization: string,
      body?: StorageFileCreateSynchronizationAPI,
      Accept?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).addStorageConnectionSourcefile(
        connectionId,
        Authorization,
        body,
        Accept,
        options
      )(fetch, basePath);
    },
    /**
     * ---    Create a StorageConnection that describes files from Storage to synchronize to the iModel.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.    ### Associated entities    A connection is linked with an iModel. An iModel ID is required to be set when creating a StorageConnection.    ---
     * @summary Create StorageConnection
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {StorageConnectionCreateSynchronizationAPI} [body]
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    createStorageConnection(
      Authorization: string,
      body?: StorageConnectionCreateSynchronizationAPI,
      Accept?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).createStorageConnection(
        Authorization,
        body,
        Accept,
        options
      )(fetch, basePath);
    },
    /**
     * ---    Delete connection    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.      ---
     * @summary Delete StorageConnection
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteStorageConnection(
      connectionId: string,
      Authorization: string,
      Accept?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).deleteStorageConnection(
        connectionId,
        Authorization,
        Accept,
        options
      )(fetch, basePath);
    },
    /**
     * ---    Retrieves the calling user's AuthorizationInformation.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get AuthorizationInformation
     * @param {string} redirectUrl URL to redirect back to after authorization
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getAuthorizationInformation(
      redirectUrl: string,
      Authorization: string,
      Accept?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).getAuthorizationInformation(
        redirectUrl,
        Authorization,
        Accept,
        options
      )(fetch, basePath);
    },
    /**
     * ---    Retrieves connections for the specified iModel.    ### Notes    The `Prefer` header can be used to specify how much result metadata is desired by the client. The `Prefer` request header field is used to indicate that particular server behaviors are preferred by the client but are not required for successful completion of the request.    This operation supports `\"return=representation\"` and `\"return=minimal\"` preferences.    The `\"return=representation\"` preference indicates that the client prefers that the server include an entity representing the current state of the resource in the response to a successful request.  The `\"return=minimal\"` preference indicates that the client wishes the server to return only a minimal response to a successful request. This is the default preference if `Prefer` header is not specified.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get Connections
     * @param {string} imodelId iModel Id
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {number} [top] The [$top](https://www.odata.org/getting-started/basic-tutorial/#topskip) system query option requests the number of items in the queried collection to be included in the result.
     * @param {number} [skip] The [$skip](https://www.odata.org/getting-started/basic-tutorial/#topskip) query option requests the number of items in the queried collection that are to be skipped and not included in the result.
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getConnections(
      imodelId: string,
      Authorization: string,
      top?: number,
      skip?: number,
      Accept?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).getConnections(
        imodelId,
        Authorization,
        top,
        skip,
        Accept,
        options
      )(fetch, basePath);
    },
    /**
     * ---    Retrieves a StorageConnection with the specified ID.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get Storage Connection
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConnection(
      connectionId: string,
      Authorization: string,
      Accept?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).getStorageConnection(
        connectionId,
        Authorization,
        Accept,
        options
      )(fetch, basePath);
    },
    /**
     * ---    Retrieves a StorageConnection Run with the specified ID.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get Storage Connection Run
     * @param {string} connectionId
     * @param {string} runId Run Id
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {number} [top] The [$top](https://www.odata.org/getting-started/basic-tutorial/#topskip) system query option requests the number of items in the queried collection to be included in the result.
     * @param {number} [skip] The [$skip](https://www.odata.org/getting-started/basic-tutorial/#topskip) query option requests the number of items in the queried collection that are to be skipped and not included in the result.
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConnectionRun(
      connectionId: string,
      runId: string,
      Authorization: string,
      top?: number,
      skip?: number,
      Accept?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).getStorageConnectionRun(
        connectionId,
        runId,
        Authorization,
        top,
        skip,
        Accept,
        options
      )(fetch, basePath);
    },
    /**
     * ---    Retrieves all Runs for the specified connection.    ### Notes    The `Prefer` header can be used to specify how much result metadata is desired by the client. The `Prefer` request header field is used to indicate that particular server behaviors are preferred by the client but are not required for successful completion of the request.    This operation supports `\"return=representation\"` and `\"return=minimal\"` preferences.    The `\"return=representation\"` preference indicates that the client prefers that the server include an entity representing the current state of the resource in the response to a successful request.  The `\"return=minimal\"` preference indicates that the client wishes the server to return only a minimal response to a successful request. This is the default preference if `Prefer` header is not specified.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get StorageConnection Runs
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConnectionRuns(
      connectionId: string,
      Authorization: string,
      Accept?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).getStorageConnectionRuns(
        connectionId,
        Authorization,
        Accept,
        options
      )(fetch, basePath);
    },
    /**
     * ---    Retrieves StorageConnection's SourceFile with the specified ID.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get StorageConnection SourceFile
     * @param {string} connectionId
     * @param {string} sourceFileId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {number} [top] The [$top](https://www.odata.org/getting-started/basic-tutorial/#topskip) system query option requests the number of items in the queried collection to be included in the result.
     * @param {number} [skip] The [$skip](https://www.odata.org/getting-started/basic-tutorial/#topskip) query option requests the number of items in the queried collection that are to be skipped and not included in the result.
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConnectionSourcefile(
      connectionId: string,
      sourceFileId: string,
      Authorization: string,
      top?: number,
      skip?: number,
      Accept?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).getStorageConnectionSourcefile(
        connectionId,
        sourceFileId,
        Authorization,
        top,
        skip,
        Accept,
        options
      )(fetch, basePath);
    },
    /**
     * ---    Retrieves SourceFiles for specified StorageConnection.    ### Notes    The `Prefer` header can be used to specify how much result metadata is desired by the client. The `Prefer` request header field is used to indicate that particular server behaviors are preferred by the client but are not required for successful completion of the request.    This operation supports `\"return=representation\"` and `\"return=minimal\"` preferences.    The `\"return=representation\"` preference indicates that the client prefers that the server include an entity representing the current state of the resource in the response to a successful request.  The `\"return=minimal\"` preference indicates that the client wishes the server to return only a minimal response to a successful request. This is the default preference if `Prefer` header is not specified.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
     * @summary Get StorageConnection SourceFiles
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getStorageConnectionSourcefiles(
      connectionId: string,
      Authorization: string,
      Accept?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).getStorageConnectionSourcefiles(
        connectionId,
        Authorization,
        Accept,
        options
      )(fetch, basePath);
    },
    /**
     * ---    Delete StorageConnection SourceFile    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.      ---
     * @summary Remove StorageConnection SourceFile
     * @param {string} connectionId Connection Id
     * @param {string} sourceFileId SourceFile Id
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    removeStorageConnectionSourcefile(
      connectionId: string,
      sourceFileId: string,
      Authorization: string,
      Accept?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).removeStorageConnectionSourcefile(
        connectionId,
        sourceFileId,
        Authorization,
        Accept,
        options
      )(fetch, basePath);
    },
    /**
     * ---    Runs the specified StorageConnection.    ### Notes    On successful run, operation returns http status code 202/accepted - the request is accepted for processing and will execute in background. It returns location header pointing to the run to check it's status via property 'State'(NotStarted, Idle, WaitingToExecute, WaitingToRetry, Executing, Completed, Queued). In the event that multiple run requests are being made simultaneously, 409/conflict is returned and only the first request is processed. If the run is already initiated and active, a new run is not initiated, instead 303/see other is returned along with location header pointing to the active run. There can only be one active run per iModel and another run can be initated only once the active run is complete.    ### Authentication    Requires Authorization header with valid Bearer token for scope *connection:modify*.    ---
     * @summary Run StorageConnection
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runStorageConnection(
      connectionId: string,
      Authorization: string,
      Accept?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).runStorageConnection(
        connectionId,
        Authorization,
        Accept,
        options
      )(fetch, basePath);
    },
    /**
     * ---    Update an existing StorageConnection.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.    ### Associated entities    A connection is linked with an iModel. The iModel ID is required to be set when updating a StorageConnection.    ---
     * @summary Update StorageConnection
     * @param {string} connectionId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {StorageConnectionCreateSynchronizationAPI} [body]
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStorageConnection(
      connectionId: string,
      Authorization: string,
      body?: StorageConnectionCreateSynchronizationAPI,
      Accept?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).updateStorageConnection(
        connectionId,
        Authorization,
        body,
        Accept,
        options
      )(fetch, basePath);
    },
    /**
     * ---    Update an existing StorageConnection SourceFile.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.    #### ConnectorType    Valid ConnectorType values are:    -NotSet  -AFFINITYCHECKER  -MSTN  -AVEVAPID  -AUTOPLANT  -REVIT  -DWG  -SPXREVIEW  -IFC  -SPPID  -AVEVADIAGRAMS  -CIVIL  -CIVIL3D  -GEOSPATIAL  -OBD  -OPENTOWER  -SHELLEDWCSV  -NWD    ### Associated entities  SourceFile is related to a Connection. The path must contain a valid Connection ID.    ---
     * @summary Update StorageConnection SourceFile
     * @param {string} connectionId
     * @param {string} sourceFileId
     * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
     * @param {StorageFileCreateSynchronizationAPI} [body]
     * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateStorageConnectionSourcefile(
      connectionId: string,
      sourceFileId: string,
      Authorization: string,
      body?: StorageFileCreateSynchronizationAPI,
      Accept?: string,
      options?: any
    ) {
      return DefaultApiFp(configuration).updateStorageConnectionSourcefile(
        connectionId,
        sourceFileId,
        Authorization,
        body,
        Accept,
        options
      )(fetch, basePath);
    },
  };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
  /**
   * ---    Add a new Storage Source File to a Storage Connection    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.    #### ConnectorType    Valid ConnectorType values are:    -NotSet  -AFFINITYCHECKER  -MSTN  -AVEVAPID  -AUTOPLANT  -REVIT  -DWG  -SPXREVIEW  -IFC  -SPPID  -AVEVADIAGRAMS  -CIVIL  -CIVIL3D  -GEOSPATIAL  -OBD  -OPENTOWER  -SHELLEDWCSV  -NWD    ### Associated entities  SourceFile is added to a Connection. The reuqest path must contain a valid Connection ID    ---
   * @summary Add StorageConnection SourceFile
   * @param {string} connectionId
   * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
   * @param {StorageFileCreateSynchronizationAPI} [body]
   * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public addStorageConnectionSourcefile(
    connectionId: string,
    Authorization: string,
    body?: StorageFileCreateSynchronizationAPI,
    Accept?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).addStorageConnectionSourcefile(
      connectionId,
      Authorization,
      body,
      Accept,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * ---    Create a StorageConnection that describes files from Storage to synchronize to the iModel.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.    ### Associated entities    A connection is linked with an iModel. An iModel ID is required to be set when creating a StorageConnection.    ---
   * @summary Create StorageConnection
   * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
   * @param {StorageConnectionCreateSynchronizationAPI} [body]
   * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public createStorageConnection(
    Authorization: string,
    body?: StorageConnectionCreateSynchronizationAPI,
    Accept?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).createStorageConnection(
      Authorization,
      body,
      Accept,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * ---    Delete connection    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.      ---
   * @summary Delete StorageConnection
   * @param {string} connectionId
   * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
   * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public deleteStorageConnection(
    connectionId: string,
    Authorization: string,
    Accept?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).deleteStorageConnection(
      connectionId,
      Authorization,
      Accept,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * ---    Retrieves the calling user's AuthorizationInformation.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
   * @summary Get AuthorizationInformation
   * @param {string} redirectUrl URL to redirect back to after authorization
   * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
   * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getAuthorizationInformation(
    redirectUrl: string,
    Authorization: string,
    Accept?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).getAuthorizationInformation(
      redirectUrl,
      Authorization,
      Accept,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * ---    Retrieves connections for the specified iModel.    ### Notes    The `Prefer` header can be used to specify how much result metadata is desired by the client. The `Prefer` request header field is used to indicate that particular server behaviors are preferred by the client but are not required for successful completion of the request.    This operation supports `\"return=representation\"` and `\"return=minimal\"` preferences.    The `\"return=representation\"` preference indicates that the client prefers that the server include an entity representing the current state of the resource in the response to a successful request.  The `\"return=minimal\"` preference indicates that the client wishes the server to return only a minimal response to a successful request. This is the default preference if `Prefer` header is not specified.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
   * @summary Get Connections
   * @param {string} imodelId iModel Id
   * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
   * @param {number} [top] The [$top](https://www.odata.org/getting-started/basic-tutorial/#topskip) system query option requests the number of items in the queried collection to be included in the result.
   * @param {number} [skip] The [$skip](https://www.odata.org/getting-started/basic-tutorial/#topskip) query option requests the number of items in the queried collection that are to be skipped and not included in the result.
   * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getConnections(
    imodelId: string,
    Authorization: string,
    top?: number,
    skip?: number,
    Accept?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).getConnections(
      imodelId,
      Authorization,
      top,
      skip,
      Accept,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * ---    Retrieves a StorageConnection with the specified ID.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
   * @summary Get Storage Connection
   * @param {string} connectionId
   * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
   * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getStorageConnection(
    connectionId: string,
    Authorization: string,
    Accept?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).getStorageConnection(
      connectionId,
      Authorization,
      Accept,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * ---    Retrieves a StorageConnection Run with the specified ID.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
   * @summary Get Storage Connection Run
   * @param {string} connectionId
   * @param {string} runId Run Id
   * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
   * @param {number} [top] The [$top](https://www.odata.org/getting-started/basic-tutorial/#topskip) system query option requests the number of items in the queried collection to be included in the result.
   * @param {number} [skip] The [$skip](https://www.odata.org/getting-started/basic-tutorial/#topskip) query option requests the number of items in the queried collection that are to be skipped and not included in the result.
   * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getStorageConnectionRun(
    connectionId: string,
    runId: string,
    Authorization: string,
    top?: number,
    skip?: number,
    Accept?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).getStorageConnectionRun(
      connectionId,
      runId,
      Authorization,
      top,
      skip,
      Accept,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * ---    Retrieves all Runs for the specified connection.    ### Notes    The `Prefer` header can be used to specify how much result metadata is desired by the client. The `Prefer` request header field is used to indicate that particular server behaviors are preferred by the client but are not required for successful completion of the request.    This operation supports `\"return=representation\"` and `\"return=minimal\"` preferences.    The `\"return=representation\"` preference indicates that the client prefers that the server include an entity representing the current state of the resource in the response to a successful request.  The `\"return=minimal\"` preference indicates that the client wishes the server to return only a minimal response to a successful request. This is the default preference if `Prefer` header is not specified.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
   * @summary Get StorageConnection Runs
   * @param {string} connectionId
   * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
   * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getStorageConnectionRuns(
    connectionId: string,
    Authorization: string,
    Accept?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).getStorageConnectionRuns(
      connectionId,
      Authorization,
      Accept,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * ---    Retrieves StorageConnection's SourceFile with the specified ID.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
   * @summary Get StorageConnection SourceFile
   * @param {string} connectionId
   * @param {string} sourceFileId
   * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
   * @param {number} [top] The [$top](https://www.odata.org/getting-started/basic-tutorial/#topskip) system query option requests the number of items in the queried collection to be included in the result.
   * @param {number} [skip] The [$skip](https://www.odata.org/getting-started/basic-tutorial/#topskip) query option requests the number of items in the queried collection that are to be skipped and not included in the result.
   * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getStorageConnectionSourcefile(
    connectionId: string,
    sourceFileId: string,
    Authorization: string,
    top?: number,
    skip?: number,
    Accept?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).getStorageConnectionSourcefile(
      connectionId,
      sourceFileId,
      Authorization,
      top,
      skip,
      Accept,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * ---    Retrieves SourceFiles for specified StorageConnection.    ### Notes    The `Prefer` header can be used to specify how much result metadata is desired by the client. The `Prefer` request header field is used to indicate that particular server behaviors are preferred by the client but are not required for successful completion of the request.    This operation supports `\"return=representation\"` and `\"return=minimal\"` preferences.    The `\"return=representation\"` preference indicates that the client prefers that the server include an entity representing the current state of the resource in the response to a successful request.  The `\"return=minimal\"` preference indicates that the client wishes the server to return only a minimal response to a successful request. This is the default preference if `Prefer` header is not specified.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:read`.    ---
   * @summary Get StorageConnection SourceFiles
   * @param {string} connectionId
   * @param {string} Authorization OAuth access token with scope &#x60;synchronization:read&#x60;
   * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public getStorageConnectionSourcefiles(
    connectionId: string,
    Authorization: string,
    Accept?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).getStorageConnectionSourcefiles(
      connectionId,
      Authorization,
      Accept,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * ---    Delete StorageConnection SourceFile    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.      ---
   * @summary Remove StorageConnection SourceFile
   * @param {string} connectionId Connection Id
   * @param {string} sourceFileId SourceFile Id
   * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
   * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public removeStorageConnectionSourcefile(
    connectionId: string,
    sourceFileId: string,
    Authorization: string,
    Accept?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).removeStorageConnectionSourcefile(
      connectionId,
      sourceFileId,
      Authorization,
      Accept,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * ---    Runs the specified StorageConnection.    ### Notes    On successful run, operation returns http status code 202/accepted - the request is accepted for processing and will execute in background. It returns location header pointing to the run to check it's status via property 'State'(NotStarted, Idle, WaitingToExecute, WaitingToRetry, Executing, Completed, Queued). In the event that multiple run requests are being made simultaneously, 409/conflict is returned and only the first request is processed. If the run is already initiated and active, a new run is not initiated, instead 303/see other is returned along with location header pointing to the active run. There can only be one active run per iModel and another run can be initated only once the active run is complete.    ### Authentication    Requires Authorization header with valid Bearer token for scope *connection:modify*.    ---
   * @summary Run StorageConnection
   * @param {string} connectionId
   * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
   * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public runStorageConnection(
    connectionId: string,
    Authorization: string,
    Accept?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).runStorageConnection(
      connectionId,
      Authorization,
      Accept,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * ---    Update an existing StorageConnection.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.    ### Associated entities    A connection is linked with an iModel. The iModel ID is required to be set when updating a StorageConnection.    ---
   * @summary Update StorageConnection
   * @param {string} connectionId
   * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
   * @param {StorageConnectionCreateSynchronizationAPI} [body]
   * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateStorageConnection(
    connectionId: string,
    Authorization: string,
    body?: StorageConnectionCreateSynchronizationAPI,
    Accept?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).updateStorageConnection(
      connectionId,
      Authorization,
      body,
      Accept,
      options
    )(this.fetch, this.basePath);
  }

  /**
   * ---    Update an existing StorageConnection SourceFile.    ### Authentication    Requires `Authorization` header with valid Bearer token for scope `synchronization:modify`.    #### ConnectorType    Valid ConnectorType values are:    -NotSet  -AFFINITYCHECKER  -MSTN  -AVEVAPID  -AUTOPLANT  -REVIT  -DWG  -SPXREVIEW  -IFC  -SPPID  -AVEVADIAGRAMS  -CIVIL  -CIVIL3D  -GEOSPATIAL  -OBD  -OPENTOWER  -SHELLEDWCSV  -NWD    ### Associated entities  SourceFile is related to a Connection. The path must contain a valid Connection ID.    ---
   * @summary Update StorageConnection SourceFile
   * @param {string} connectionId
   * @param {string} sourceFileId
   * @param {string} Authorization OAuth access token with scope &#x60;synchronization:modify&#x60;
   * @param {StorageFileCreateSynchronizationAPI} [body]
   * @param {string} [Accept] Setting to &#x60;application/vnd.bentley.itwin-platform.v1+json&#x60; is recommended.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof DefaultApi
   */
  public updateStorageConnectionSourcefile(
    connectionId: string,
    sourceFileId: string,
    Authorization: string,
    body?: StorageFileCreateSynchronizationAPI,
    Accept?: string,
    options?: any
  ) {
    return DefaultApiFp(this.configuration).updateStorageConnectionSourcefile(
      connectionId,
      sourceFileId,
      Authorization,
      body,
      Accept,
      options
    )(this.fetch, this.basePath);
  }
}
